innobase_start_or_create_for_mysql() is the init start for innodb server

innobase/jandler/ja_innodb.cc is the handler for innodb plugin, its innobase_init is calling innobase_start_or_create_for_mysql to initialize innodb.

Innodb has its thread pool, os threads, buffer pool ready before return to mysql server that it is ready. We don't need all the details here.

/* The InnoDB handler: the interface between MySQL and InnoDB. */

read ha_innobase::write_row() as example from innobase/handler/ha_innobase.cc


m_prebuilt = row_create_prebuilt(ib_table, table->s->reclength); ï¼š initialized a long list of staff, struct defined in rwo0mysql.cc

top layer of innodb call:
ha_innobase::write_row() ->
-> row_insert_for_mysql() in rwo0mysql.cc -> row_insert_for_mysql_using_ins_graph()
  -> row_get_prebuilt_insert_row()
  -> row_mysql_convert_row_to_innobase()
  -> row_ins_step(thr)
  -> row_ins_index_entry_step() -> row_ins_clust_index_entry() (row0ins.cc) -> row_ins_clust_index_entry_low()
  -> btr_cur_optimistic_insert() : this one finally lead to a btree operation, this is the close of the inseart call or in other words end layer of it.

code path read from https://dev.mysql.com/doc/internals/en/guided-tour-chunk.html to get clear on the first half before reaching the ha_innobase::write_row()
---------------------------------------
the following code path are done for going through the path for mysql start to finish an update

// /sql/mysqld.cc
main() {
  ...
  // initialize the mysql server data stucture etc
  mysqld_socket_acceptor->connection_event_loop();
  // if the above loop is done, mysqld is shutting down
}

// /sql/conn_handler/connection_acceptor.cc
connection_event_loop() {
    while(!abort()) {
      wait_for_conn();
      Connection_handler_manager::process_new_connection();
    }
}

// /sql/conn_handler/connection_acceptor.cc
process_new_connection() {
    ....
    Per_thread_connection_handler::add_connection();
}

Per_thread_connection_handler::add_connection() {
    mysql_thread_create(); -> which is a definition of my_thread_create(); // mysql_thread.cc where my_thread_handle* is the passed in handler and will be executed in a new pthread to do the job.
    // the handler is implemented with C in static void *handle_connection(void *arg) {} in connection_handler_per_thread.cc
    
    init_new_thd(channel_info) {
       channel_info->create_thd();
       thd_set_thread_stack(thd, (char *)&thd); // this only do one thing: set the stack address, nothing else
       store_globals(); // store some thread info
    }
    
    
    thd_prepare_connection(thd) {
      login_connection(); // auth user
      
      thd_prepare_connection();
      while (thd_connection_alive(thd)) {
        if (do_command(thd)) break; // in do_command in sql_parse.cc, it will figure out command and do return_value = dispatch_command(thd, &com_data, command);
      }
    }
    
    // this should connects with the mysql_update following
    
    // seems that sql/conn_handler/channel_info.h and .cc plays an inportant roll in passing down info for what to do
    // seems not, still has gap on how it figure out what to call next
    
    /*
     This abstract base class represents connection channel information
     about a new connection. Its subclasses encapsulate differences
     between different connection channel types.
    */
    
    
}

bool mysql_update() { // refactored, now it is Query_result_update::do_updates() it seems in sql_update.cc
  // crazy optimizers ***
  ...
  // read
  init_read_record(); 
  ...
   while (true) {
       if (error || thd.killed) {
           break;
       }
       
       if (will_batch) {
           error= table->file->ha_bulk_update_row(); // in mysql 8.0 we are still doing ha_update_row() to call innodb handler etc, the outer logic changed a bit in detail
       } else {
           error= table->file->ha_update_row();
       }
   }
}


ha_update_row() {
   ha_innobase::update_row(); // => here we get to innodb, yeah!!!!
}

https://dev.mysql.com/doc/internals/en/guided-tour-skeleton.html
