------------------------------------------------
Section 10. Use tracer bullets
It is possible to use the concept of tracer bullets in machine gun to programming and building a new system.
The advantage over full design and construct models separately is we will have a working sys and make progress and problem visible for whole system.

1. Use tracer code, i.e. build a simple skeleton of the whole system with minimum functionality.
2. Add component to it. This makes it easier to provide sth working, have a structure that helps everyone to make more progress, easier to
   debug and test comparing to implemention without a whole skeleton and functionality.
3. The tracer code may not be working, make change for the small part of code to fix it. This can be discovered earlier.

Note about prototyping: it will generate some one-use code before refactor and re-implementation in the final environment. It can servers as
the reconnaissance of tracer code.

------------------------------------------------
Section 1. The cat ate my source code.
Take responsibility, make back up and other preparation. Instead of providing excuses, try to provide options. Before that, try what people may
think about to solve the problem. This will make the staff easier I guess.

When sth goes wrong, just be honest and admit it. Try to fix it.

------------------------------------------------
Section 2. Software Entropy
The code in a project tends to get messy as time goes by. This is the tradition of the universe. Try to stop it.

1. Broken window: if some of the code is broken/in bad status, it is easy to lead a trend and make the whole project goes stupid. Fix small
   problems when discovered.
2. Fireman: a good, clean project will help the programmer to keep this good trend and make the next steps clean as it is now.

------------------------------------------------
Section 3 
catalyst 催化
Stone soup and boiled frogs

When you start a whole project, it is hard and time consuming to gather all the resources at once. People won't join an empty
party. Just start and do something, and add staff, ask for help and resources step by step. People like to join a process of
success.

On the other hand, do have a big picture in mind. Don't get further and further from your target during patching and patching. Otherwise
might be like the poor frog trapped and died in a pot with heated code water.

------------------------------------------------
Section 4 good enough software
There is resource, timeline, budget issues for all teams and software. The users won't wait for longer time for a perfect software. They 
want sth that can fullfill their requirment now, even if it has problems in other aspects. So make progress, have a resonable line (eg. I am
ok with maintaining this thing in the future, users are ok with these features). 

Don't spend too much time in polish and ruin the software by patching and patching without release.

------------------------------------------------
section 5 your knowledge portfolio
Learning is important. Only be learning new things can we keep ourself useful.

Don't put all the eggs in one basket, learn sth different.
   -Learn a new language each year.
   -Read a new tech book eqch quarter, even if you don't use that technique in project.
   -Read sth else, remember we are working with human.
   -Try to find sth new and useful, try to do sth interesting.
Talk to people when facing problem that can't be solved now. Try to fins a solution

Time is of short supply, make a plan accordingly.

------------------------------------------------
Section 6 communicate

Get to know sth:
   - is it ok to talk now?
   - make doc look clean and good
   - get audience involoved
   - always get back to others

-------------------------------------------------
Secion 7 reduce duplication

-------------------------------------------------
Section 8 Orthogonality

To make a system orithogonality, we decouple each part of the system. The code of different part should be able to change separately
as long as we keep some defined interface.

Try to make component independent, single and well designed purpose.  The code is easier to chanege, make it more productive and not that likely to make mistake.
Easier to test.

Orthogonality design: a layered approach, this approach makes it easier, the system's upper layer only dependes on lower layer. Watch out for RMI!

- keep your code decoupled
- avoid global data
- avoid similar functions

Test is also easier.


-----------------------------------------------------
Section 9 Reversibility 可逆性 ????????

Components should be flexible, changable. The change shouldn't take so much time, otherwise it would be a design problem.

Further understanding is needed.

-----------------------------------------------------
Section 11. Prototypes and Post-it notes
We can use prototypes to try sth and find problems. We mainly value the experience learned from prototype, not the code
we got.

- when making prototype, focus on the point you want to analyze. Don't try to make it a working solution.
- if you need a working solution also, try tracer bullet.
- when prototype archecture, we may not need a real production, just a picture is also helpful.

- high level language may be helpful when prototype, even if we don't use them in real project.

----------------------------------------------------
Section 12 Domain language
People using different language may think differently, stay close to the problem domain. Don't go too far from it with wrong tools.
????????

----------------------------------------------------
Section 13 Estimating
We need estimtion about the process, system workload,.......
The estimation should come with correct unit, eg accuracy. 
When try to do sth new and needs an estimation, ask sb who has done sth related or similar.

A model and design may be helpful for the estimation.
For coding, update your estimation as working through the problem
----------------------------------------------------
Section 14 The power of plain text

Plain text is easy to use, easy to read, easy to test. It may need more space for storage and more computation to read when used for metadata.
We can operate on it in any tool
XML may be useful.
XML 指可扩展标记语言（EXtensible Markup Language）
XML 是一种标记语言，很类似 HTML
XML 的设计宗旨是传输数据，而非显示数据
XML 标签没有被预定义。您需要自行定义标签。
XML 被设计为具有自我描述性。

leverage  杠杆作用
-----------------------------------------------------
Section 15 Shell Games
find . -name '*.c' -newer Makefile -print

construct an archive of  source files:
zip archive.zip *.h *.c

find file not changed last week:
fins . -name '*.java' -mtime +7 -print

find files using a lib:
find . -name '*.java' -print | xargs grep 'java.awt'

UWIM is a unix env in windows
-----------------------------------------------------
Section 16 Power Editing
Learn an editor well (I need to learn vim...)
Remember about the extensions.
-----------------------------------------------------
Section 17 Source control
-----------------------------------------------------

Section 36 The requirement pit

Get requirement is hard. They are not well defined. We need not only understand what is described,
but also why is that and how the user goes to the current requreiment mode.

Since the user requirement might change, it is better to use some metadata for a clear view and further usage.
Be a user might be helpful.

Have a good note of requirement is a good idea. This needs goal, use conditions, extensions, target priority, schedule and so on. P 206, 207

diagram is helpful

Requirement should be abstract, they are not design!!!!!!!

See further, make some staff abstract/flexible for the future.

Maintain a glossary/doc for the project.

-----------------------------------------------
Section 37 Solving impossible puzzles
Someimes we may face some probles that are so confusing, harder than we expected.

- are we constraining ourselves???, we might not need to fullfill all the constrains we think. List them, list possible ways, prove or use it.
- don't just think outside the box, we need find the box, real box!!!

When work hard with problems, think:
- Is there an easier way?
- Is this the problem we want to solve?
- Is this staff must be done in this way?
- Do we really need to solve this problem? Can we just skip it?

|\
| \
|  \
|   \
*----*
|    | \
*____*__\___________

We are using three lines to connect the four points and go back to start pos!
The virtual constraint: we assume we need to make a turn at the points: this is not true!!!!
-----------------------------------------------
