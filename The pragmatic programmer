------------------------------------------------
Section 10. Use tracer bullets
It is possible to use the concept of tracer bullets in machine gun to programming and building a new system.
The advantage over full design and construct models separately is we will have a working sys and make progress and problem visible for whole system.

1. Use tracer code, i.e. build a simple skeleton of the whole system with minimum functionality.
2. Add component to it. This makes it easier to provide sth working, have a structure that helps everyone to make more progress, easier to
   debug and test comparing to implemention without a whole skeleton and functionality.
3. The tracer code may not be working, make change for the small part of code to fix it. This can be discovered earlier.

Note about prototyping: it will generate some one-use code before refactor and re-implementation in the final environment. It can servers as
the reconnaissance of tracer code.

------------------------------------------------
Section 1. The cat ate my source code.
Take responsibility, make back up and other preparation. Instead of providing excuses, try to provide options. Before that, try what people may
think about to solve the problem. This will make the staff easier I guess.

When sth goes wrong, just be honest and admit it. Try to fix it.

------------------------------------------------
Section 2. Software Entropy
The code in a project tends to get messy as time goes by. This is the tradition of the universe. Try to stop it.

1. Broken window: if some of the code is broken/in bad status, it is easy to lead a trend and make the whole project goes stupid. Fix small
   problems when discovered.
2. Fireman: a good, clean project will help the programmer to keep this good trend and make the next steps clean as it is now.

------------------------------------------------
Section 3 
catalyst 催化
Stone soup and boiled frogs

When you start a whole project, it is hard and time consuming to gather all the resources at once. People won't join an empty
party. Just start and do something, and add staff, ask for help and resources step by step. People like to join a process of
success.

On the other hand, do have a big picture in mind. Don't get further and further from your target during patching and patching. Otherwise
might be like the poor frog trapped and died in a pot with heated code water.

------------------------------------------------
Section 4 good enough software
There is resource, timeline, budget issues for all teams and software. The users won't wait for longer time for a perfect software. They 
want sth that can fullfill their requirment now, even if it has problems in other aspects. So make progress, have a resonable line (eg. I am
ok with maintaining this thing in the future, users are ok with these features). 

Don't spend too much time in polish and ruin the software by patching and patching without release.

------------------------------------------------
section 5 your knowledge portfolio
Learning is important. Only be learning new things can we keep ourself useful.

Don't put all the eggs in one basket, learn sth different.
   -Learn a new language each year.
   -Read a new tech book eqch quarter, even if you don't use that technique in project.
   -Read sth else, remember we are working with human.
   -Try to find sth new and useful, try to do sth interesting.
Talk to people when facing problem that can't be solved now. Try to fins a solution

Time is of short supply, make a plan accordingly.

------------------------------------------------
Section 6 communicate

Get to know sth:
   - is it ok to talk now?
   - make doc look clean and good
   - get audience involoved
   - always get back to others

-------------------------------------------------
Secion 7 reduce duplication

-------------------------------------------------
Section 8 Orthogonality

To make a system orithogonality, we decouple each part of the system. The code of different part should be able to change separately
as long as we keep some defined interface.

Try to make component independent, single and well designed purpose.  The code is easier to chanege, make it more productive and not that likely to make mistake.
Easier to test.

Orthogonality design: a layered approach, this approach makes it easier, the system's upper layer only dependes on lower layer. Watch out for RMI!

- keep your code decoupled
- avoid global data
- avoid similar functions

Test is also easier.


-----------------------------------------------------
Section 9 Reversibility 可逆性 ????????

Components should be flexible, changable. The change shouldn't take so much time, otherwise it would be a design problem.

Further understanding is needed.




